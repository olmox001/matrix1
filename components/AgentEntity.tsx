import React, { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Agent, AgentRole, ModuleState } from '../types';
import * as THREE from 'three';
import { Html } from '@react-three/drei';
import { useMatrixStore } from '../store';
import { queryOllama } from '../services/ollamaService';
import { MATRIX_GREEN, AGENT_RED } from '../constants';

interface AgentEntityProps {
  agent: Agent;
}

export const AgentEntity: React.FC<AgentEntityProps> = ({ agent }) => {
  const groupRef = useRef<THREE.Group>(null);
  const config = useMatrixStore(s => s.config);
  const updateAgent = useMatrixStore(s => s.updateAgent);
  const addModule = useMatrixStore(s => s.addModule);
  const addLog = useMatrixStore(s => s.addLog);
  const removeModule = useMatrixStore(s => s.removeModule);
  
  const [thinking, setThinking] = useState(false);
  const lastThoughtTime = useRef(0);

  // Movement Logic
  useFrame((state, delta) => {
    if (!groupRef.current) return;

    // Smooth lerp to target
    if (agent.targetPosition) {
      const current = groupRef.current.position;
      const target = new THREE.Vector3(agent.targetPosition.x, agent.targetPosition.y, agent.targetPosition.z);
      
      const dist = current.distanceTo(target);
      
      if (dist > 0.1) {
        const dir = target.clone().sub(current).normalize();
        const speed = agent.role === AgentRole.ARCHITECT ? 5 : 2; // Architects move fast
        
        groupRef.current.position.add(dir.multiplyScalar(speed * delta));
        
        // Update store with actual position occasionally
        if (state.clock.elapsedTime % 1 < 0.1) {
             updateAgent(agent.id, { 
                 position: { x: current.x, y: current.y, z: current.z } 
             });
        }
      } else {
        // Arrived
        if (agent.status === 'moving') {
            updateAgent(agent.id, { status: 'idle' });
        }
      }
    }

    // AI Brain Tick
    const time = state.clock.elapsedTime;
    if (config.useAI && !thinking && time - lastThoughtTime.current > 4) {
      // Think every 4 seconds
      decideNextAction(time);
    }
  });

  const decideNextAction = async (time: number) => {
    setThinking(true);
    lastThoughtTime.current = time;

    try {
      updateAgent(agent.id, { status: 'analyzing' });
      
      const response = await queryOllama(
        agent, 
        `Nearby modules: ${useMatrixStore.getState().modules.length}. Status: ${agent.status}`, 
        config.ollamaUrl, 
        config.modelName
      );

      // Execute Action
      if (response.action === 'MOVE') {
        updateAgent(agent.id, { 
            targetPosition: { x: response.target[0], y: response.target[1], z: response.target[2] },
            status: 'moving',
            currentTask: response.reason
        });
      } else if (response.action === 'BUILD') {
          // Physical Interaction: Create Module
          addModule({
              id: crypto.randomUUID(),
              position: { x: response.target[0], y: response.target[1], z: response.target[2] },
              type: 'cube',
              state: ModuleState.STABLE,
              integrity: 100,
              dataPayload: 'Generated by ' + agent.role,
              createdAt: Date.now()
          });
          addLog(`[${agent.role}] Built module at ${response.target}`);
          updateAgent(agent.id, { currentTask: 'Building ' + response.reason, status: 'building' });
      } else if (response.action === 'DELETE') {
          // Find closest module to delete target (simple mock)
          // In a real physics engine, we'd raycast. Here we assume the target is an ID or close coord
          const mods = useMatrixStore.getState().modules;
          if (mods.length > 0) {
              removeModule(mods[0].id); // Just remove oldest for demo safety
              addLog(`[${agent.role}] Purged module.`);
          }
      }

    } catch (e) {
      console.error(e);
    } finally {
      setThinking(false);
    }
  };

  // Visuals per role
  const color = agent.role === AgentRole.ARCHITECT ? '#FFFFFF' : agent.role === AgentRole.SUPERVISOR ? '#FFFF00' : MATRIX_GREEN;
  const geometry = agent.role === AgentRole.ARCHITECT ? <octahedronGeometry args={[0.8]} /> : agent.role === AgentRole.SUPERVISOR ? <sphereGeometry args={[0.5]} /> : <coneGeometry args={[0.3, 1, 4]} />;

  return (
    <group ref={groupRef} position={[agent.position.x, agent.position.y, agent.position.z]}>
      <mesh>
        {geometry}
        <meshStandardMaterial color={color} wireframe emissive={color} emissiveIntensity={2} />
      </mesh>
      
      {/* Permission/Vision Range */}
      <mesh rotation={[Math.PI / 2, 0, 0]} visible={false}>
         <ringGeometry args={[agent.permissionLevel * 2, agent.permissionLevel * 2 + 0.1, 32]} />
         <meshBasicMaterial color={color} side={THREE.DoubleSide} transparent opacity={0.2} />
      </mesh>

      <Html distanceFactor={15}>
        <div className="bg-black/80 border border-green-500 text-[8px] text-green-500 p-1 w-24 font-mono pointer-events-none select-none">
          <div className="font-bold">{agent.role}</div>
          <div>{agent.status}</div>
          <div className="truncate text-[6px] opacity-70">{agent.currentTask}</div>
        </div>
      </Html>
    </group>
  );
};